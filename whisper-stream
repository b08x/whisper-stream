#!/bin/bash
source ~/.env

# Check if gum is installed
if ! command -v gum &> /dev/null; then
    echo "Error: gum is not installed. Please install it (https://github.com/charmbracelet/gum) to use this feature."
    exit 1
fi

# Default configuration and versioning
VERSION="1.1.0"

# Setting the default values for the script parameters
MIN_VOLUME=1%                  # Minimum volume threshold
SILENCE_LENGTH=1.5             # Minimum silence duration in seconds
ONESHOT=false                  # Flag to determine if the script should run once or continuously
DURATION=0                     # Duration of the recording in seconds (0 means continuous)
WHISPER_URL_TRANSLATIONS="https://api.groq.com/openai/v1/audio/translations"
WHISPER_URL_TRANSCRIPTIONS="https://api.groq.com/openai/v1/audio/transcriptions"
MODEL="whisper-large-v3-turbo"              # Model for the OpenAI API
TOKEN="${GROQ_API_KEY}"                       # OpenAI API token
OUTPUT_DIR=""                  # Directory to save the transcriptions
DEST_FILE=""       # File to write the transcriptions to
PROMPT=""                      # Prompt for the API call
LANGUAGE=""                    # Language code for transcription
TRANSLATE=""                   # Flag to indicate translation to English
AUDIO_FILE=""                  # Specific audio file for transcription
PIPE_TO_CMD=""                 # Command to pipe the transcribed text to
QUIET_MODE=false               # Flag to determine if the banner and settings should be suppressed
GRANULARITIES="none"           # Timestamp granularities for transcription: segment or word
NOTEBOOK_ROOT="${HOME}/Notebooks"
NOTEBOOK=""

# Display help information for script usage
function display_help() {
  echo "Usage: $0 [options]"
  echo "Options:"
  echo "  -v, --volume <value>        Set the minimum volume threshold (default: 1%)"
  echo "  -s, --silence <value>       Set the minimum silence length (default: 1.5)"
  echo "  -o, --oneshot               Enable one-shot mode"
  echo "  -d, --duration <value>      Set the recording duration in seconds (default: 0, continuous)"
  echo "  -t, --token <value>         Set the OpenAI API token"
  echo "  -nr, --notebooks-root <value>          Set the Notebooks root directory"
  echo "  -n, --notebook <value>          Set the Notebook to store dictations"
  echo "  -g, --granularities <value> Set the timestamp granularities (segment or word)"
  echo "  -r, --prompt <value>        Set the prompt for the API call"
  echo "  -l, --language <value>      Set the language in ISO-639-1 format"
  echo "  -f, --file <value>          Set the audio file to be transcribed"
  echo "  -tr, --translate            Translate the transcribed text to English"
  echo "  -p2, --pipe-to <cmd>        Pipe the transcribed text to the specified command (e.g., 'wc -m')"
  echo "  -df <file>, --dest-file <file>  Set the destination file for transcriptions"
  echo "  -V, --version               Show the version number"
  echo "  -q, --quiet                 Suppress the banner and settings"
  echo "  -h, --help                  Display this help message"
  echo "To stop the app, press Ctrl+C"
  exit 0
}

# Check the validity of the provided audio file
function check_audio_file() {
  local file=$1

  # Check if the file exists
  if [ ! -f "$file" ]; then
    echo "File does not exist: $file"
    exit 1
  fi

  # Check if the file is not empty
  if [ ! -s "$file" ]; then
    echo "File is empty: $file"
    exit 1
  fi

# Check if the file size is under 25MB
  local filesize
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    filesize=$(stat -c%s "$file")
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    filesize=$(stat -f%z "$file")
  else
    echo "Unknown operating system"
    exit 1
  fi
  if [ $filesize -gt 26214400 ]; then
    echo "File size is over 25MB: $file"
    exit 1
  fi

  # Check if the file format is acceptable
  local ext="${file##*.}"
  case "$ext" in
    m4a|mp3|webm|mp4|mpga|wav|mpeg)
      ;;
    *)
      echo "File format is not acceptable: $file"
      exit 1
      ;;
  esac
}

# Parse command-line arguments to set script parameters
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -v|--volume)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      MIN_VOLUME="$2"
      if [[ "$MIN_VOLUME" != *% ]]; then
        MIN_VOLUME+="%"
      fi
      shift
      shift
      ;;
    -s|--silence)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      SILENCE_LENGTH="$2"
      shift
      shift
      ;;
    -o|--oneshot)
      ONESHOT=true
      shift
      ;;
    -d|--duration)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      DURATION="$2"
      shift
      shift
      ;;
    -t|--token)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      TOKEN="$2"
      shift
      shift
      ;;
    -nr|--notebook-root)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      NOTEBOOK_ROOT="$2"
      shift
      shift
      ;;      
    -n|--notebook)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      NOTEBOOK="$2"
      # check if the output directory exists
      if [ ! -d "$NOTEBOOK_ROOT/$NOTEBOOK" ]; then
        echo "Directory does not exist: $NOTEBOOK_ROOT/$NOTEBOOK"
        exit 1
      fi
      shift
      shift
      ;;
    -g|--granularities)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      GRANULARITIES="$2"
      shift
      shift
      ;;
    -r|--prompt)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      PROMPT="$2"
      shift
      shift
      ;;
    -l|--language)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      LANGUAGE="$2"
      shift
      shift
      ;;
    -tr|--translate)
      TRANSLATE=true
      shift
      ;;
    -p2|--pipe-to)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing cmd for $1"
        exit 1
      fi
      PIPE_TO_CMD="$2"
      shift
      shift
      ;;
    -f|--file)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      AUDIO_FILE="$2"
      check_audio_file "$AUDIO_FILE"
      shift
      shift
      ;;
    -V|--version)
      SHOW_VERSION=true
      shift
      ;;
    -q|--quiet)
      QUIET_MODE=true
      shift
      ;;
    -h|--help)
      display_help
      ;;
    -df|--dest-file)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      DEST_FILE="$2"
      # Ensure the directory exists if a full path is given
      OUTPUT_DIR=$(dirname "$DEST_FILE")
      if [ ! -d "$OUTPUT_DIR" ]; then
         mkdir -p "$OUTPUT_DIR" || { echo "Error: Could not create directory $OUTPUT_DIR"; exit 1; }
      fi
      shift # past argument
# If no audio file is specified via -f, ask the user for input source and device
if [ -z "$AUDIO_FILE" ]; then
  INPUT_CHOICE=$(gum choose "Record from Microphone" "Transcribe from File" --header "Choose input source")

  # Handle user cancellation
  if [ -z "$INPUT_CHOICE" ]; then
    echo "No input source selected. Exiting."
    exit 0
  fi

  if [ "$INPUT_CHOICE" == "Transcribe from File" ]; then
    # Use gum file to select an audio file
    SELECTED_FILE=$(gum file --file --height 15 --header "Select an audio file")

    # Handle user cancellation
    if [ -z "$SELECTED_FILE" ]; then
      echo "No file selected. Exiting."
      exit 0
    fi

    # Use realpath to get the absolute path robustly
    AUDIO_FILE=$(realpath "$SELECTED_FILE" 2>/dev/null) || { echo "Error resolving path: $SELECTED_FILE"; exit 1; }

    # Validate the selected file
    check_audio_file "$AUDIO_FILE"
  elif [ "$INPUT_CHOICE" == "Record from Microphone" ]; then
    # Select the input device
    SELECTED_INPUT_DEVICE=$(select_input_device)
    # select_input_device returns non-zero on error/cancel but might return "" for default
    # We proceed even if it fails, falling back to the system default
    if [ $? -ne 0 ] && [ -z "$SELECTED_INPUT_DEVICE" ]; then
        echo "Proceeding with system default input device due to selection error or cancellation." >&2
    elif [ -n "$SELECTED_INPUT_DEVICE" ] && [ "$SELECTED_INPUT_DEVICE" != "System Default" ]; then
        echo "Selected input device: $SELECTED_INPUT_DEVICE" >&2
    # else: System Default was chosen explicitly or implicitly
    fi
    # AUDIO_FILE remains empty, script proceeds to recording loop
  fi
fi
      shift # past value
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Display version if the version flag is set
if [ "$SHOW_VERSION" = true ]; then
  echo "Whisper Stream Speech-to-Text Transcriber (version: $VERSION)"
  exit
fi

# Fetch OpenAI API token from environment if not provided as an argument
if [ -z "$TOKEN" ]; then
  TOKEN="${OPENAI_API_KEY:-}"
# Function to list available audio input devices on macOS
function list_macos_input_devices() {
  if command -v SwitchAudioSource &> /dev/null; then
    SwitchAudioSource -a -t input
  else
    # Fallback or error message if SwitchAudioSource is not found
    echo "Error: SwitchAudioSource not found. Cannot list devices." >&2
    return 1
  fi
}

# Function to list available audio input devices on Linux (using pactl or arecord)
function list_linux_input_devices() {
  if command -v pactl &> /dev/null; then
    # Get PulseAudio source names (often more user-friendly)
    pactl list short sources | awk '{print $2}'
  elif command -v arecord &> /dev/null; then
     # Fallback to ALSA devices if pactl isn't available
     arecord -l | grep '^card' | sed -e 's/card \([0-9]*\): \(.*\), device \([0-9]*\):.*/hw:\1,\3 \[\2]/' | awk -F ' [' '{print $1}'
  else
    echo "Error: pactl or arecord not found. Cannot list devices." >&2
    return 1
  fi
}

# Function to select an input device using gum
function select_input_device() {
  local os_type=$(uname)
  local devices_list=()
  local selected_device=""

  echo "Detecting input devices..." # Add some feedback

  if [[ "$os_type" == "Darwin" ]]; then
    # Read devices into an array
    mapfile -t devices_list < <(list_macos_input_devices)
  elif [[ "$os_type" == "Linux" ]]; then
    mapfile -t devices_list < <(list_linux_input_devices)
  else
    echo "Unsupported OS for device selection: $os_type" >&2
    return 1 # Indicate failure
  fi

  if [ ${#devices_list[@]} -eq 0 ]; then
    echo "No input devices found or could not list devices. Using system default." >&2
    echo "" # Return empty string to signify default
    return 1 # Indicate potential issue but allow fallback
  fi

  # Use gum choose to select a device
  # Increase height based on number of devices, capped at ~20
  local gum_height=${#devices_list[@]}
  [ $gum_height -gt 20 ] && gum_height=20
  # Add a "System Default" option
  selected_device=$(printf "System Default\n%s\n" "${devices_list[@]}" | gum choose --header "Select Input Device" --height $((gum_height + 1)) )


  # Handle cancellation or explicit "System Default" selection
  if [ -z "$selected_device" ] || [ "$selected_device" == "System Default" ]; then
      echo "Using system default input device." >&2
      echo "" # Return empty string to signify default
      return 0 # Not an error
  fi

  echo "$selected_device"
  return 0 # Indicate success
}

# Variable to store the selected device ID/Name
SELECTED_INPUT_DEVICE=""
fi

# If no token is provided as an argument or environment variable, exit the script
if [ -z "$TOKEN" ]; then
  echo "No OpenAI API key provided. Please provide it as an argument or environment variable."
  exit 1
fi

output_files=() # Array to store the names of output audio files

# Function to get the name of the current audio input device on macOS
function get_macos_input_device() {
  # if SwitchAudioSource command available
  if [ -x "$(command -v SwitchAudioSource)" ]; then
    local input_device=$(SwitchAudioSource -t input -c)
    echo "$input_device"
    return
  fi
}

# Function to get the volume of the audio input on macOS
function get_macos_input_volume() {
  local input_volume=$(osascript -e "input volume of (get volume settings)")
  echo "$input_volume%"
}

# Function to get the name of the current audio input device on Linux
function get_linux_input_device() {
  # if arecord command available
  if [ -x "$(command -v arecord)" ]; then
    local input_device=$(arecord -l | grep -oP "(?<=card )\d+(?=:\s.*\[)")
    echo "hw:$input_device"
    return
  fi
}

function get_linux_input_volume() {
  # Check if amixer command is available and executable
  if [ -x "$(command -v amixer)" ]; then
    local input_volume=$(amixer sget Capture | grep 'Left:' | awk -F'[][]' '{ print $2 }')
    echo "$input_volume"
    return
  fi
}

# Function to display current settings
function display_settings() {
  if [ "$QUIET_MODE" = true ]; then
    return
  fi

  echo ""
  echo $'\e[1;34m'Whisper Stream Speech-to-Text Transcriber$'\e[0m' ${VERSION}
  echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
  echo "Current settings:"
  echo "  Volume threshold: $MIN_VOLUME"
  echo "  Silence length: $SILENCE_LENGTH seconds"
  echo "  Input language: ${LANGUAGE:-Not specified}"

  if [ -n "$TRANSLATE" ]; then
    echo "  Translate to English: $TRANSLATE"
  fi
  
  if [ -n "$OUTPUT_DIR" ]; then
    echo "  Output Dir: $OUTPUT_DIR"
  fi

	if [ -n "$DEST_FILE" ]; then
		echo "  Destination File: $DEST_FILE"
	fi

  # Display selected or default input device
  if [ -n "$SELECTED_INPUT_DEVICE" ] && [ "$SELECTED_INPUT_DEVICE" != "System Default" ]; then
      echo "  Selected Input Device: $SELECTED_INPUT_DEVICE"
  else
      # Try to get the system default device name for display purposes
      local default_device_display=$(get_input_device) # Use existing function
      if [ -n "$default_device_display" ]; then
          echo "  Input device: $default_device_display (System Default)"
      else
          echo "  Input device: System Default"
      fi
  fi

  # Get the input volume based on the operating system
  local input_volume=$(get_input_volume)
  if [ -n "$input_volume" ]; then
    echo "  Input volume: $input_volume"
  fi
  
  echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
  echo To stop the app, press $'\e[0;36m'Ctrl+C$'\e[0m'
  echo ""
}

# Get the name of the current audio input device based on OS
function get_input_device() {
  case "$(uname)" in
    Darwin)
      get_macos_input_device
      ;;
    Linux)
      get_linux_input_device
      ;;
    *)
      echo "Unknown operating system"
      ;;
  esac
}

# Get the volume level of the current audio input device based on OS
function get_input_volume() {
  case "$(uname)" in
    Darwin)
      get_macos_input_volume
      ;;
    Linux)
      get_linux_input_volume
      ;;
    *)
      echo "Unknown operating system"
      ;;
  esac
}

# Display a rotating spinner animation
function spinner() {
  local pid=$1
  local delay=0.1
  local spinstr='|/-\\'
  while kill -0 $pid 2>/dev/null; do
    local temp=${spinstr#?}
    printf "\r\e[1;31m%c\e[0m" "$spinstr"
    local spinstr=$temp${spinstr%"$temp"}
    sleep $delay
  done
  printf "\r\e[K"
}

# Convert the audio to text using the OpenAI Whisper API
function convert_audio_to_text() {
  local output_file=$1
  if [ -n "$TRANSLATE" ]; then
    base_url="$WHISPER_URL_TRANSLATIONS"
  else
    base_url="$WHISPER_URL_TRANSCRIPTIONS"
  fi
  local curl_command="curl -s --request POST \
    --url $base_url \
    --header \"Authorization: Bearer ${TOKEN}\" \
    --header \"Content-Type: multipart/form-data\" \
    --form \"file=@$output_file\" \
    --form \"model=$MODEL\" \
    --form \"temperature=0.02\" \
    --form \"response_format=verbose_json\""

  # Add optional parameters to the curl command when GANULARITIES is not set to none
  if [ "$GRANULARITIES" != "none" ]; then
    curl_command+=" --form \"timestamp_granularities[]=${GRANULARITIES}\""
  fi

  if [ -n "$PROMPT" ]; then
    curl_command+=" --form \"prompt=$PROMPT\""
  fi

  if [ -n "$LANGUAGE" ]; then
    curl_command+=" --form \"language=$LANGUAGE\""
  fi

  maxretries=3

  response=$(eval $curl_command)
  # Check if the curl command was successful
  # retry until successful or max retries reached
  while [ $? -ne 0 ] && [ $maxretries -gt 0 ]; do
    # print a red dot to indicate a failed API call
    printf "\e[1;31m.\e[0m"
    response=$(eval $curl_command)
    maxretries=$((maxretries - 1))
  done

  # if GRAINULARITIES is set to `none`, `.text` will be returned
  if [ "$GRANULARITIES" != "none" ]; then
    transcription=$(echo "$response")
  else
    transcription=$(echo "$response" | jq -r '.text' | sd '^\s' '')
  fi
  
  # Check if the curl command was successful
  # retry until successful or max retries reached
  while [ $? -ne 0 ] && [ $maxretries -gt 0 ]; do
    # print a red dot to indicate a failed API call
    printf "\e[1;31m.\e[0m"
    response=$(eval $curl_command)
    maxretries=$((maxretries - 1))
  done

  printf "\r\e[K"
	xsel -cb
	xsel -a -b <<<$transcription  
  echo "$transcription"

	if [ -n "${DEST_FILE}" ]; then
		# Write the transcription to the destination file
		# LLMEDIT=$(aichat -r transcription_editor 'NLP' "${transcription}")
		echo "$transcription" >> "${DEST_FILE}"
		# echo "$LLMEDIT" >> "${DEST_FILE}"
	fi

  if [ -n "$PIPE_TO_CMD" ]; then
    result=$(echo "$transcription" | $PIPE_TO_CMD)
    echo $result
  fi
  
  # Remove the output audio file unless the `-f` option is specified
  if [ -z "$AUDIO_FILE" ]; then
    rm -f "$output_file"
  fi
  
  # Accumulate the transcribed text in a temporary file
  # this is necessary for the data to be available when the script terminates
  echo "$transcription" >> temp_transcriptions.txt
}

# Handle the script termination: clean up and save transcriptions
function handle_exit() {
  # Wait for all background jobs to finish
  wait

  # Kill all child processes
  pkill -P $$

  # Remove all output audio files
  for file in "${output_files[@]}"; do
    rm -f "$file"
  done

  # if temp_transcriptions.txt exists, remove it
  if [ -f temp_transcriptions.txt ]; then
    # read data from temp_transcriptions.txt into the accumulated_text variable
    # and remove temp_transcriptions.txt
    accumulated_text=$(cat temp_transcriptions.txt)
    rm -f temp_transcriptions.txt
    # Clear the current line
    printf "\r\e[K\n"
  else
    printf "\r\e[K"
    exit
  fi

  # If output directory is specified, create a file with the accumulated text in the specified directory
  if [ -n "$OUTPUT_DIR" ]; then
    timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    # if GRAINULARITIES is set to `none`, a text file will be created
    if [ "$GRANULARITIES" != "none" ]; then
      echo "$accumulated_text" > "$OUTPUT_DIR/transcription_$timestamp.json"
    # otherwise, a JSON file will be created
    else
      echo "$accumulated_text" > "$OUTPUT_DIR/transcription_$timestamp.txt"
    fi
  fi

  # Copy the accumulated text to the clipboard
  case "$(uname -s)" in
    Darwin)
      # if $accumulated_text is not empty
      if [ -n "$accumulated_text" ]; then
        echo "$accumulated_text" > temp.txt
        cat temp.txt | pbcopy
        rm temp.txt
        echo $'\e[0;36m'Transcription copied to clipboard.$'\e[0m'
      fi
      ;;
    Linux)
      echo "$accumulated_text" | xclip -selection clipboard >&1
      ;;
    CYGWIN*|MINGW32*|MSYS*|MINGW*)
      # This is a rough guess that you're on Windows Subsystem for Linux
      # if $accumulated_text is not empty
      if [ -n "$accumulated_text" ]; then
        echo "$accumulated_text" | clip.exe >&1
        echo $'\e[0;36m'Transcription copied to clipboard.$'\e[0m'
      fi
      ;;
    *)
      echo "Unknown OS, cannot copy to clipboard"
      ;;
  esac

  exit
}

# If an audio file is provided, convert it to text and then exit
if [ -n "$AUDIO_FILE" ]; then

  # print banner and settings unless quiet mode is enabled
  # this is necessary for the data to be available when the script terminates
  if [ "$QUIET_MODE" = false ]; then
    echo ""
    echo $'\e[1;34m'Whisper Stream Transcriber$'\e[0m' ${VERSION}
    echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
    echo "Current settings:"
    echo "  Input language: ${LANGUAGE:-Not specified}"

    if [ -n "$TRANSLATE" ]; then
      echo "  Translate to English: $TRANSLATE"
    fi
    
    if [ -n "$OUTPUT_DIR" ]; then
      echo "  Output Dir: $OUTPUT_DIR"
    fi

    echo "  Input file: $AUDIO_FILE"
    echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
    echo $'\e[0;36m'Please wait ...$'\e[0m'
    echo ""
  fi

  convert_audio_to_text "$AUDIO_FILE"
  handle_exit
fi

# Display the current configuration/settings of the script
display_settings

# Handle script termination using trap for SIGINT (Ctrl+C) and SIGTSTP (Ctrl+Z)
trap handle_exit SIGINT SIGTSTP

# Main loop to continuously record audio, detect silence, and transcribe audio
while true; do
  # Set the path to the output audio file
  OUTPUT_FILE="output_$(date +%s).wav"
  
  # Add the output file to the array
  output_files+=("$OUTPUT_FILE")

  # Add a prompt at the beginning of the recording
  # echo -n $'\e[1;32m'▶ $'\e[0m'

  # Construct rec command arguments
  REC_ARGS=("-q" "-V0" "-e" "signed" "-L" "-c" "1" "-b" "16" "-r" "16000" "-t" "raw")

  # Add device if selected and not default
  if [ -n "$SELECTED_INPUT_DEVICE" ] && [ "$SELECTED_INPUT_DEVICE" != "System Default" ]; then
      # Special handling for macOS if SwitchAudioSource was used
      if [[ "$(uname)" == "Darwin" ]] && command -v SwitchAudioSource &> /dev/null; then
          # Attempt to set the device using SwitchAudioSource
          SwitchAudioSource -t input -s "$SELECTED_INPUT_DEVICE"
          if [ $? -ne 0 ]; then
              echo "Warning: Failed to set input device using SwitchAudioSource. Using system default." >&2
          else
              # No need to pass -d to rec as SwitchAudioSource changes the system default
              : # Placeholder, action is done
          fi
      else
          # For Linux or macOS without SwitchAudioSource, pass -d
          # Ensure we pass the correct device format (e.g., hw:X,Y for ALSA)
          # The list_linux_input_devices function already provides this format
          REC_ARGS+=("-d" "$SELECTED_INPUT_DEVICE")
      fi
  fi

  REC_ARGS+=("-") # Output to stdout

  # Add effects based on duration
  if [ "$DURATION" -gt 0 ]; then
    REC_ARGS+=("trim" "0" "$DURATION" "silence" "1" "0.1" "$MIN_VOLUME" "1" "$SILENCE_LENGTH" "$MIN_VOLUME")
  else
    REC_ARGS+=("silence" "1" "0.1" "$MIN_VOLUME" "1" "$SILENCE_LENGTH" "$MIN_VOLUME")
  fi

  # Record audio using constructed arguments
  rec "${REC_ARGS[@]}" | sox -t raw -r 16000 -b 16 -e signed -c 1 - "$OUTPUT_FILE"
  
  # Check if the audio file is created successfully
  if [ -s "$OUTPUT_FILE" ]; then
    # Convert the MP3 audio to text using the Whisper API in the background
    convert_audio_to_text "$OUTPUT_FILE" &

    # Captures the process ID of the last executed background command.
    pid=$!
    spinner $pid &
    # Read the transcriptions into the accumulated_text variable
  else
    echo "No audio recorded."
  fi

  if [ "$ONESHOT" = true ]; then
    break
  fi
done

# Handle final cleanup and exit
handle_exit
