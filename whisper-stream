#!/bin/bash
source ~/.env

# Set up error logging
ERROR_LOG="/tmp/whisper-stream-error.log"
exec 2> >(tee -a "$ERROR_LOG" >&2)

# Function to log errors with timestamp
function log_error() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$ERROR_LOG"
}

# Function to rotate error log if it gets too large
function rotate_error_log() {
  if [[ -f "$ERROR_LOG" && $(stat -f%z "$ERROR_LOG" 2>/dev/null || stat -c%s "$ERROR_LOG" 2>/dev/null) -gt 1048576 ]]; then
    # If log is larger than 1MB, keep only the last 500 lines
    tail -n 500 "$ERROR_LOG" > "${ERROR_LOG}.tmp" && mv "${ERROR_LOG}.tmp" "$ERROR_LOG"
    log_error "Log rotated - keeping last 500 lines"
  fi
}

# Initialize error logging
rotate_error_log
log_error "whisper-stream started (PID: $$)"

# Check if gum is installed
if ! command -v gum &> /dev/null; then
    echo "Error: gum is not installed. Please install it (https://github.com/charmbracelet/gum) to use this feature."
    exit 1
fi

# Default configuration and versioning
VERSION="1.2.0"

# Setting the default values for the script parameters
MIN_VOLUME=1%                  # Minimum volume threshold
SILENCE_LENGTH=1.5             # Minimum silence duration in seconds
ONESHOT=false                  # Flag to determine if the script should run once or continuously
DURATION=0                     # Duration of the recording in seconds (0 means continuous)
WHISPER_URL_TRANSLATIONS="https://api.groq.com/openai/v1/audio/translations"
WHISPER_URL_TRANSCRIPTIONS="https://api.groq.com/openai/v1/audio/transcriptions"
MODEL="whisper-large-v3-turbo"              # Model for the OpenAI API
TOKEN="${GROQ_API_KEY}"                       # OpenAI API token
OUTPUT_DIR=""                  # Directory to save the transcriptions
DEST_FILE=""       # File to write the transcriptions to
PROMPT=""                      # Prompt for the API call
LANGUAGE=""                    # Language code for transcription
TRANSLATE=""                   # Flag to indicate translation to English
AUDIO_FILE=""                  # Specific audio file for transcription
PIPE_TO_CMD=""                 # Command to pipe the transcribed text to
QUIET_MODE=false               # Flag to determine if the banner and settings should be suppressed
GRANULARITIES="none"           # Timestamp granularities for transcription: segment or word
NOTEBOOK_ROOT="${HOME}/Notebooks"
NOTEBOOK=""

# Display help information for script usage
function display_help() {
  echo "Usage: $0 [options]"
  echo "Options:"
  echo "  -v, --volume <value>        Set the minimum volume threshold (default: 1%)"
  echo "  -s, --silence <value>       Set the minimum silence length (default: 1.5)"
  echo "  -o, --oneshot               Enable one-shot mode"
  echo "  -d, --duration <value>      Set the recording duration in seconds (default: 0, continuous)"
  echo "  -t, --token <value>         Set the OpenAI API token"
  echo "  -nr, --notebooks-root <value>          Set the Notebooks root directory"
  echo "  -n, --notebook <value>          Set the Notebook to store dictations"
  echo "  -g, --granularities <value> Set the timestamp granularities (segment or word)"
  echo "  -r, --prompt <value>        Set the prompt for the API call"
  echo "  -l, --language <value>      Set the language in ISO-639-1 format"
  echo "  -f, --file <value>          Set the audio file to be transcribed"
  echo "  -i, --input-device <value>  Set the input device for recording"
  echo "  -tr, --translate            Translate the transcribed text to English"
  echo "  -p2, --pipe-to <cmd>        Pipe the transcribed text to the specified command (e.g., 'wc -m')"
  echo "  -df <file>, --dest-file <file>  Set the destination file for transcriptions"
  echo "  -V, --version               Show the version number"
  echo "  -q, --quiet                 Suppress the banner and settings"
  echo "  -h, --help                  Display this help message"
  echo "To stop the app, press Ctrl+C"
  exit 0
}

# Check the validity of the provided audio file
function check_audio_file() {
  local file=$1

  # Check if the file exists
  if [ ! -f "$file" ]; then
    echo "File does not exist: $file"
    exit 1
  fi

  # Check if the file is not empty
  if [ ! -s "$file" ]; then
    echo "File is empty: $file"
    exit 1
  fi

# Check if the file size is under 25MB
  local filesize
  if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    filesize=$(stat -c%s "$file")
  elif [[ "$OSTYPE" == "darwin"* ]]; then
    filesize=$(stat -f%z "$file")
  else
    echo "Unknown operating system"
    exit 1
  fi
  if [ $filesize -gt 26214400 ]; then
    echo "File size is over 25MB: $file"
    exit 1
  fi

  # Check if the file format is acceptable
  local ext="${file##*.}"
  case "$ext" in
    m4a|mp3|webm|mp4|mpga|wav|mpeg)
      ;;
    *)
      echo "File format is not acceptable: $file"
      exit 1
      ;;
  esac
}

# Function to load configuration from config file
function load_config() {
  local config_file="$HOME/.config/whisper-stream/config"
  
  if [[ -f "$config_file" ]]; then
    while IFS='=' read -r key value || [[ -n "$key" ]]; do
      # Skip empty lines and comments
      [[ "$key" =~ ^[[:space:]]*$ ]] && continue
      [[ "$key" =~ ^[[:space:]]*# ]] && continue
      
      # Remove leading/trailing whitespace
      key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
      
      # Remove quotes if present
      value=$(echo "$value" | sed 's/^"//;s/"$//')
      
      case "$key" in
        MIN_VOLUME) MIN_VOLUME="$value" ;;
        SILENCE_LENGTH) SILENCE_LENGTH="$value" ;;
        ONESHOT) 
          if [[ "$value" =~ ^(true|yes|1)$ ]]; then
            ONESHOT=true
          else
            ONESHOT=false
          fi
          ;;
        DURATION) DURATION="$value" ;;
        TOKEN) TOKEN="$value" ;;
        OUTPUT_DIR) OUTPUT_DIR="$value" ;;
        DEST_FILE) DEST_FILE="$value" ;;
        PROMPT) PROMPT="$value" ;;
        LANGUAGE) LANGUAGE="$value" ;;
        TRANSLATE)
          if [[ "$value" =~ ^(true|yes|1)$ ]]; then
            TRANSLATE="true"
          else
            TRANSLATE=""
          fi
          ;;
        AUDIO_FILE) AUDIO_FILE="$value" ;;
        PIPE_TO_CMD) PIPE_TO_CMD="$value" ;;
        QUIET_MODE)
          if [[ "$value" =~ ^(true|yes|1)$ ]]; then
            QUIET_MODE=true
          else
            QUIET_MODE=false
          fi
          ;;
        GRANULARITIES) GRANULARITIES="$value" ;;
        NOTEBOOK_ROOT) NOTEBOOK_ROOT="$value" ;;
        NOTEBOOK) NOTEBOOK="$value" ;;
        SELECTED_INPUT_DEVICE) SELECTED_INPUT_DEVICE="$value" ;;
      esac
    done < "$config_file"
  fi
}

# Function to write selected device back to config file
function write_device_to_config() {
  local device="$1"
  local config_file="$HOME/.config/whisper-stream/config"
  local config_dir="$HOME/.config/whisper-stream"
  
  # Create config directory if it doesn't exist
  mkdir -p "$config_dir"
  
  # If config file doesn't exist, create it with default values first
  if [[ ! -f "$config_file" ]]; then
    cat > "$config_file" << 'EOF'
# whisper-stream configuration file
# This file is loaded when whisper-stream is called without arguments

# Audio recording settings
MIN_VOLUME=1%
SILENCE_LENGTH=1.5
ONESHOT=false
DURATION=0

# API settings
# TOKEN=your_groq_api_key_here

# Output settings
OUTPUT_DIR=""
DEST_FILE=""
QUIET_MODE=false

# Transcription settings
PROMPT=""
LANGUAGE=""
TRANSLATE=false
GRANULARITIES=none

# Notebook settings
NOTEBOOK_ROOT=${HOME}/Notebooks
NOTEBOOK=""

# Device settings
SELECTED_INPUT_DEVICE=""

# Advanced settings
AUDIO_FILE=""
PIPE_TO_CMD=""
EOF
  fi
  
  # Update the SELECTED_INPUT_DEVICE line in the config file
  if grep -q "^SELECTED_INPUT_DEVICE=" "$config_file"; then
    # Replace existing line
    sed -i "s/^SELECTED_INPUT_DEVICE=.*/SELECTED_INPUT_DEVICE=\"$device\"/" "$config_file"
  else
    # Add new line if it doesn't exist
    echo "SELECTED_INPUT_DEVICE=\"$device\"" >> "$config_file"
  fi
  
  echo "Saved device selection to config: $device" >&2
}

# Function to write notebook root back to config file
function write_notebook_root_to_config() {
  local notebook_root="$1"
  local config_file="$HOME/.config/whisper-stream/config"
  local config_dir="$HOME/.config/whisper-stream"
  
  # Create config directory if it doesn't exist
  mkdir -p "$config_dir"
  
  # If config file doesn't exist, create it with default values first
  if [[ ! -f "$config_file" ]]; then
    cat > "$config_file" << 'EOF'
# whisper-stream configuration file
# This file is loaded when whisper-stream is called without arguments

# Audio recording settings
MIN_VOLUME=1%
SILENCE_LENGTH=1.5
ONESHOT=false
DURATION=0

# API settings
# TOKEN=your_groq_api_key_here

# Output settings
OUTPUT_DIR=""
DEST_FILE=""
QUIET_MODE=false

# Transcription settings
PROMPT=""
LANGUAGE=""
TRANSLATE=false
GRANULARITIES=none

# Notebook settings
NOTEBOOK_ROOT=${HOME}/Notebooks
NOTEBOOK=""

# Device settings
SELECTED_INPUT_DEVICE=""

# Advanced settings
AUDIO_FILE=""
PIPE_TO_CMD=""
EOF
  fi
  
  # Update the NOTEBOOK_ROOT line in the config file
  if grep -q "^NOTEBOOK_ROOT=" "$config_file"; then
    # Replace existing line
    sed -i "s|^NOTEBOOK_ROOT=.*|NOTEBOOK_ROOT=\"$notebook_root\"|" "$config_file"
  else
    # Add new line if it doesn't exist
    echo "NOTEBOOK_ROOT=\"$notebook_root\"" >> "$config_file"
  fi
  
  echo "Saved notebook root to config: $notebook_root" >&2
}

# Load config file if no arguments provided
if [[ $# -eq 0 ]]; then
  load_config
fi

# Parse command-line arguments to set script parameters
while [[ $# -gt 0 ]]; do
  key="$1"
  case $key in
    -v|--volume)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      MIN_VOLUME="$2"
      if [[ "$MIN_VOLUME" != *% ]]; then
        MIN_VOLUME+="%"
      fi
      shift
      shift
      ;;
    -s|--silence)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      SILENCE_LENGTH="$2"
      shift
      shift
      ;;
    -o|--oneshot)
      ONESHOT=true
      shift
      ;;
    -d|--duration)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      DURATION="$2"
      shift
      shift
      ;;
    -t|--token)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      TOKEN="$2"
      shift
      shift
      ;;
    -nr|--notebook-root)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      NOTEBOOK_ROOT="$2"
      shift
      shift
      ;;      
    -n|--notebook)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      NOTEBOOK="$2"
      # check if the output directory exists
      if [ ! -d "$NOTEBOOK_ROOT/$NOTEBOOK" ]; then
        echo "Directory does not exist: $NOTEBOOK_ROOT/$NOTEBOOK"
        exit 1
      fi
      shift
      shift
      ;;
    -g|--granularities)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      GRANULARITIES="$2"
      shift
      shift
      ;;
    -r|--prompt)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      PROMPT="$2"
      shift
      shift
      ;;
    -l|--language)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      LANGUAGE="$2"
      shift
      shift
      ;;
    -tr|--translate)
      TRANSLATE=true
      shift
      ;;
    -p2|--pipe-to)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing cmd for $1"
        exit 1
      fi
      PIPE_TO_CMD="$2"
      shift
      shift
      ;;
    -f|--file)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      AUDIO_FILE="$2"
      check_audio_file "$AUDIO_FILE"
      shift
      shift
      ;;
    -V|--version)
      SHOW_VERSION=true
      shift
      ;;
    -q|--quiet)
      QUIET_MODE=true
      shift
      ;;
    -i|--input-device)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      SELECTED_INPUT_DEVICE="$2"
      shift
      shift
      ;;
    -h|--help)
      display_help
      ;;
    -df|--dest-file)
      if [[ ! $2 || $2 == -* ]]; then
        echo "Error: Missing value for $1"
        exit 1
      fi
      DEST_FILE="$2"
      # Ensure the directory exists if a full path is given
      OUTPUT_DIR=$(dirname "$DEST_FILE")
      if [ ! -d "$OUTPUT_DIR" ]; then
         mkdir -p "$OUTPUT_DIR" || { echo "Error: Could not create directory $OUTPUT_DIR"; exit 1; }
      fi
      shift # past argument
      shift # past value
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done


# Display version if the version flag is set
if [ "$SHOW_VERSION" = true ]; then
  echo "Whisper Stream Speech-to-Text Transcriber (version: $VERSION)"
  exit
fi

# Function to list available audio input devices on Linux
function list_input_devices() {
  if command -v pactl &> /dev/null; then
    # Use PulseAudio device names (more compatible with SoX)
    pactl list short sources | while read -r index name module format state; do
      # Skip monitor devices
      if [[ "$name" != *.monitor ]]; then
        # Get a friendly description
        local desc=$(pactl list sources | grep -A 10 "Name: $name" | grep "Description:" | sed 's/.*Description: //')
        echo "$name [$desc]"
      fi
    done
  elif command -v arecord &> /dev/null; then
    # Fallback to ALSA hardware devices
    arecord -l | grep '^card' | while read -r line; do
      card=$(echo "$line" | sed -n 's/card \([0-9]*\):.*/\1/p')
      device=$(echo "$line" | sed -n 's/.*device \([0-9]*\):.*/\1/p')
      name=$(echo "$line" | sed -n 's/.*: \([^[]*\) \[.*/\1/p')
      echo "hw:$card,$device [$name]"
    done
  else
    echo "Error: Neither pactl nor arecord found. Cannot list devices." >&2
    return 1
  fi
}

# Function to select an input device using gum
function select_input_device() {
  local devices_list=()
  
  echo "Detecting input devices..." >&2
  
  # Read devices into an array
  mapfile -t devices_list < <(list_input_devices)
  
  if [ ${#devices_list[@]} -eq 0 ]; then
    echo "No input devices found. Using system default." >&2
    echo ""
    return 1
  fi
  
  # Use gum choose to select a device
  local selected_device
  selected_device=$(printf "System Default\n%s\n" "${devices_list[@]}" | gum choose --header "Select Input Device")
  
  # Handle cancellation or "System Default" selection
  if [ -z "$selected_device" ] || [ "$selected_device" == "System Default" ]; then
    echo "Using system default input device." >&2
    echo ""
    return 0
  fi
  
  # Extract device name from the selection (remove description)
  local device_id=$(echo "$selected_device" | sed 's/\([^ ]*\) \[.*/\1/')
  echo "$device_id"
  return 0
}

# Function to generate default destination file path
function generate_default_dest_file() {
  local current_date=$(date +%Y-%m-%d)
  local current_month_year=$(date +%Y-%B)
  # Expand HOME variable properly
  local expanded_notebook_root="${NOTEBOOK_ROOT/#\$HOME/$HOME}"
  local dest_dir="$expanded_notebook_root/$current_month_year"
  local dest_file="$dest_dir/$current_date.md"
  
  # Create directory if it doesn't exist
  mkdir -p "$dest_dir"
  
  echo "$dest_file"
}

# Fetch OpenAI API token from environment if not provided as an argument
if [ -z "$TOKEN" ]; then
  TOKEN="${OPENAI_API_KEY:-}"
fi

# If no token is provided as an argument or environment variable, exit the script
if [ -z "$TOKEN" ]; then
  echo "No OpenAI API key provided. Please provide it as an argument or environment variable."
  exit 1
fi

# Check if we need to prompt for input device (only if not transcribing a file)
if [ -z "$AUDIO_FILE" ] && [ -z "$SELECTED_INPUT_DEVICE" ]; then
  echo "No input device specified. Please select an input device:"
  SELECTED_INPUT_DEVICE=$(select_input_device)
  
  # Save the selected device to config if a specific device was chosen
  if [ -n "$SELECTED_INPUT_DEVICE" ] && [ "$SELECTED_INPUT_DEVICE" != "" ]; then
    echo "Selected input device: $SELECTED_INPUT_DEVICE"
    write_device_to_config "$SELECTED_INPUT_DEVICE"
  fi
fi

# Check for notebook root directory selection if not specified or doesn't exist
if [ -z "$NOTEBOOK_ROOT" ] || [ ! -d "${NOTEBOOK_ROOT/#\$HOME/$HOME}" ]; then
  echo "Notebook root directory not specified or doesn't exist. Please select a directory:"
  SELECTED_DIR=$(gum file --directory --header "Select Notebook Root Directory" "$HOME")
  
  if [ -n "$SELECTED_DIR" ]; then
    NOTEBOOK_ROOT="$SELECTED_DIR"
    echo "Selected notebook root: $NOTEBOOK_ROOT"
    # Update config file with selected directory
    write_notebook_root_to_config "$NOTEBOOK_ROOT"
  else
    echo "No directory selected. Using default: $HOME/Notebooks"
    NOTEBOOK_ROOT="$HOME/Notebooks"
    mkdir -p "$NOTEBOOK_ROOT"
  fi
fi

# Set destination file if none specified (only for recording, not file transcription)
if [ -z "$AUDIO_FILE" ] && [ -z "$DEST_FILE" ]; then
  # Ask user to choose between auto-generated daily file or custom file selection
  DEST_CHOICE=$(gum choose "Auto-generate daily file" "Select custom file" --header "Choose destination file option")
  
  if [ "$DEST_CHOICE" == "Select custom file" ]; then
    # Let user select or create a custom destination file
    echo "Select destination file (or navigate to create a new one):"
    CUSTOM_DEST=$(gum file --file --header "Select Destination File" "${NOTEBOOK_ROOT/#\$HOME/$HOME}")
    
    if [ -n "$CUSTOM_DEST" ]; then
      DEST_FILE="$CUSTOM_DEST"
      echo "Selected destination file: $DEST_FILE"
    else
      # Fallback to auto-generated if user cancels
      DEST_FILE=$(generate_default_dest_file)
      echo "No file selected. Using auto-generated: $DEST_FILE"
    fi
  else
    # Auto-generate daily file (default behavior)
    DEST_FILE=$(generate_default_dest_file)
    echo "Using auto-generated daily file: $DEST_FILE"
  fi
fi

output_files=() # Array to store the names of output audio files

# Function to get the name of the current audio input device on macOS
function get_macos_input_device() {
  # if SwitchAudioSource command available
  if [ -x "$(command -v SwitchAudioSource)" ]; then
    local input_device=$(SwitchAudioSource -t input -c)
    echo "$input_device"
    return
  fi
}

# Function to get the volume of the audio input on macOS
function get_macos_input_volume() {
  local input_volume=$(osascript -e "input volume of (get volume settings)")
  echo "$input_volume%"
}

# Function to get the name of the current audio input device on Linux
function get_linux_input_device() {
  # if arecord command available
  if [ -x "$(command -v arecord)" ]; then
    local input_device=$(arecord -l | grep -oP "(?<=card )\d+(?=:\s.*\[)")
    echo "hw:$input_device"
    return
  fi
}

function get_linux_input_volume() {
  # Check if amixer command is available and executable
  if [ -x "$(command -v amixer)" ]; then
    local input_volume=$(amixer sget Capture | grep 'Left:' | awk -F'[][]' '{ print $2 }')
    echo "$input_volume"
    return
  fi
}

# Function to display current settings
function display_settings() {
  if [ "$QUIET_MODE" = true ]; then
    return
  fi

  echo ""
  echo $'\e[1;34m'Whisper Stream Speech-to-Text Transcriber$'\e[0m' ${VERSION}
  echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
  echo "Current settings:"
  echo "  Error log: $ERROR_LOG"
  echo "  Volume threshold: $MIN_VOLUME"
  echo "  Silence length: $SILENCE_LENGTH seconds"
  echo "  Input language: ${LANGUAGE:-Not specified}"

  if [ -n "$TRANSLATE" ]; then
    echo "  Translate to English: $TRANSLATE"
  fi
  
  if [ -n "$OUTPUT_DIR" ]; then
    echo "  Output Dir: $OUTPUT_DIR"
  fi

	if [ -n "$DEST_FILE" ]; then
		echo "  Destination File: $DEST_FILE"
	fi

  # Display selected or default input device
  if [ -n "$SELECTED_INPUT_DEVICE" ] && [ "$SELECTED_INPUT_DEVICE" != "System Default" ]; then
      echo "  Selected Input Device: $SELECTED_INPUT_DEVICE"
  else
      # Try to get the system default device name for display purposes
      local default_device_display=$(get_input_device) # Use existing function
      if [ -n "$default_device_display" ]; then
          echo "  Input device: $default_device_display (System Default)"
      else
          echo "  Input device: System Default"
      fi
  fi

  # Get the input volume based on the operating system
  local input_volume=$(get_input_volume)
  if [ -n "$input_volume" ]; then
    echo "  Input volume: $input_volume"
  fi
  
  echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
  echo To stop the app, press $'\e[0;36m'Ctrl+C$'\e[0m'
  echo ""
}

# Get the name of the current audio input device based on OS
function get_input_device() {
  case "$(uname)" in
    Darwin)
      get_macos_input_device
      ;;
    Linux)
      get_linux_input_device
      ;;
    *)
      echo "Unknown operating system"
      ;;
  esac
}

# Get the volume level of the current audio input device based on OS
function get_input_volume() {
  case "$(uname)" in
    Darwin)
      get_macos_input_volume
      ;;
    Linux)
      get_linux_input_volume
      ;;
    *)
      echo "Unknown operating system"
      ;;
  esac
}

# Display a rotating spinner animation
function spinner() {
  local pid=$1
  local delay=0.1
  local spinstr='|/-\\'
  while kill -0 $pid 2>/dev/null; do
    local temp=${spinstr#?}
    printf "\r\e[1;31m%c\e[0m" "$spinstr"
    local spinstr=$temp${spinstr%"$temp"}
    sleep $delay
  done
  printf "\r\e[K"
}

# Convert the audio to text using the OpenAI Whisper API
function convert_audio_to_text() {
  local output_file=$1
  if [ -n "$TRANSLATE" ]; then
    base_url="$WHISPER_URL_TRANSLATIONS"
  else
    base_url="$WHISPER_URL_TRANSCRIPTIONS"
  fi
  local curl_command="curl -s --request POST \
    --url $base_url \
    --header \"Authorization: Bearer ${TOKEN}\" \
    --header \"Content-Type: multipart/form-data\" \
    --form \"file=@$output_file\" \
    --form \"model=$MODEL\" \
    --form \"temperature=0.02\" \
    --form \"response_format=verbose_json\""

  # Add optional parameters to the curl command when GANULARITIES is not set to none
  if [ "$GRANULARITIES" != "none" ]; then
    curl_command+=" --form \"timestamp_granularities[]=${GRANULARITIES}\""
  fi

  if [ -n "$PROMPT" ]; then
    curl_command+=" --form \"prompt=$PROMPT\""
  fi

  if [ -n "$LANGUAGE" ]; then
    curl_command+=" --form \"language=$LANGUAGE\""
  fi

  maxretries=3

  response=$(eval $curl_command)
  # Check if the curl command was successful
  # retry until successful or max retries reached
  while [ $? -ne 0 ] && [ $maxretries -gt 0 ]; do
    # print a red dot to indicate a failed API call
    printf "\e[1;31m.\e[0m"
    response=$(eval $curl_command)
    maxretries=$((maxretries - 1))
  done

  # if GRAINULARITIES is set to `none`, `.text` will be returned
  if [ "$GRANULARITIES" != "none" ]; then
    transcription=$(echo "$response")
  else
    transcription=$(echo "$response" | jq -r '.text' | sd '^\s' '')
  fi
  
  # Check if the curl command was successful
  # retry until successful or max retries reached
  while [ $? -ne 0 ] && [ $maxretries -gt 0 ]; do
    # print a red dot to indicate a failed API call
    printf "\e[1;31m.\e[0m"
    response=$(eval $curl_command)
    maxretries=$((maxretries - 1))
  done

  printf "\r\e[K"
	xsel -cb
	xsel -a -b <<<$transcription  
  echo "$transcription"

	if [ -n "${DEST_FILE}" ]; then
		# Write the transcription to the destination file
		# LLMEDIT=$(aichat -r transcription_editor 'NLP' "${transcription}")
		echo "$transcription" >> "${DEST_FILE}"
		# echo "$LLMEDIT" >> "${DEST_FILE}"
	fi

  if [ -n "$PIPE_TO_CMD" ]; then
    result=$(echo "$transcription" | $PIPE_TO_CMD)
    echo $result
  fi
  
  # Remove the output audio file unless the `-f` option is specified
  if [ -z "$AUDIO_FILE" ]; then
    rm -f "$output_file"
  fi
  
  # Accumulate the transcribed text in a temporary file
  # this is necessary for the data to be available when the script terminates
  echo "$transcription" >> "/tmp/whisper-stream_temp_transcriptions.txt"
}

# Handle the script termination: clean up and save transcriptions
function handle_exit() {
  log_error "whisper-stream exiting (PID: $$)"
  
  # Wait for all background jobs to finish
  wait

  # Kill all child processes
  pkill -P $$

  # Remove all output audio files
  for file in "${output_files[@]}"; do
    rm -f "$file"
  done

  # if temp_transcriptions.txt exists, remove it
  if [ -f "/tmp/whisper-stream_temp_transcriptions.txt" ]; then
    # read data from temp_transcriptions.txt into the accumulated_text variable
    # and remove temp_transcriptions.txt
    accumulated_text=$(cat "/tmp/whisper-stream_temp_transcriptions.txt")
    rm -f "/tmp/whisper-stream_temp_transcriptions.txt"
    # Clear the current line
    printf "\r\e[K\n"
  else
    printf "\r\e[K"
    exit
  fi

  # If output directory is specified, create a file with the accumulated text in the specified directory
  if [ -n "$OUTPUT_DIR" ]; then
    timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    # if GRAINULARITIES is set to `none`, a text file will be created
    if [ "$GRANULARITIES" != "none" ]; then
      echo "$accumulated_text" > "$OUTPUT_DIR/transcription_$timestamp.json"
    # otherwise, a JSON file will be created
    else
      echo "$accumulated_text" > "$OUTPUT_DIR/transcription_$timestamp.txt"
    fi
  fi

  # Copy the accumulated text to the clipboard
  case "$(uname -s)" in
    Darwin)
      # if $accumulated_text is not empty
      if [ -n "$accumulated_text" ]; then
        echo "$accumulated_text" > temp.txt
        cat temp.txt | pbcopy
        rm temp.txt
        echo $'\e[0;36m'Transcription copied to clipboard.$'\e[0m'
      fi
      ;;
    Linux)
      echo "$accumulated_text" | xclip -selection clipboard >&1
      ;;
    CYGWIN*|MINGW32*|MSYS*|MINGW*)
      # This is a rough guess that you're on Windows Subsystem for Linux
      # if $accumulated_text is not empty
      if [ -n "$accumulated_text" ]; then
        echo "$accumulated_text" | clip.exe >&1
        echo $'\e[0;36m'Transcription copied to clipboard.$'\e[0m'
      fi
      ;;
    *)
      echo "Unknown OS, cannot copy to clipboard"
      ;;
  esac

  exit
}

# If an audio file is provided, convert it to text and then exit
if [ -n "$AUDIO_FILE" ]; then

  # print banner and settings unless quiet mode is enabled
  # this is necessary for the data to be available when the script terminates
  if [ "$QUIET_MODE" = false ]; then
    echo ""
    echo $'\e[1;34m'Whisper Stream Transcriber$'\e[0m' ${VERSION}
    echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
    echo "Current settings:"
    echo "  Input language: ${LANGUAGE:-Not specified}"

    if [ -n "$TRANSLATE" ]; then
      echo "  Translate to English: $TRANSLATE"
    fi
    
    if [ -n "$OUTPUT_DIR" ]; then
      echo "  Output Dir: $OUTPUT_DIR"
    fi

    echo "  Input file: $AUDIO_FILE"
    echo $'\e[1;33m'-----------------------------------------------$'\e[0m'
    echo $'\e[0;36m'Please wait ...$'\e[0m'
    echo ""
  fi

  convert_audio_to_text "$AUDIO_FILE"
  handle_exit
fi

# Display the current configuration/settings of the script
display_settings

# Handle script termination using trap for SIGINT (Ctrl+C) and SIGTSTP (Ctrl+Z)
trap handle_exit SIGINT SIGTSTP

# Main loop to continuously record audio, detect silence, and transcribe audio
while true; do
  # Set the path to the output audio file in temp directory
  OUTPUT_FILE="/tmp/whisper-stream_output_$(date +%s).wav"
  
  # Add the output file to the array
  output_files+=("$OUTPUT_FILE")

  # Add a prompt at the beginning of the recording
  # echo -n $'\e[1;32m'▶ $'\e[0m'

  # Construct rec command arguments
  if [ -n "$SELECTED_INPUT_DEVICE" ] && [ "$SELECTED_INPUT_DEVICE" != "System Default" ]; then
      # Use PulseAudio input with specific device
      REC_ARGS=("-t" "pulseaudio" "-D" "$SELECTED_INPUT_DEVICE" "-q" "-V0" "-e" "signed" "-L" "-c" "1" "-b" "16" "-r" "16000" "-t" "raw")
  else
      # Use default input
      REC_ARGS=("-q" "-V0" "-e" "signed" "-L" "-c" "1" "-b" "16" "-r" "16000" "-t" "raw")
  fi

  REC_ARGS+=("-") # Output to stdout

  # Add effects based on duration
  if [ "$DURATION" -gt 0 ]; then
    REC_ARGS+=("trim" "0" "$DURATION" "silence" "1" "0.1" "$MIN_VOLUME" "1" "$SILENCE_LENGTH" "$MIN_VOLUME")
  else
    REC_ARGS+=("silence" "1" "0.1" "$MIN_VOLUME" "1" "$SILENCE_LENGTH" "$MIN_VOLUME")
  fi

  # Record audio using constructed arguments
  rec "${REC_ARGS[@]}" | sox -t raw -r 16000 -b 16 -e signed -c 1 - "$OUTPUT_FILE"
  
  # Check if the audio file is created successfully
  if [ -s "$OUTPUT_FILE" ]; then
    # Convert the MP3 audio to text using the Whisper API in the background
    convert_audio_to_text "$OUTPUT_FILE" &

    # Captures the process ID of the last executed background command.
    pid=$!
    spinner $pid &
    # Read the transcriptions into the accumulated_text variable
  else
    echo "No audio recorded."
  fi

  if [ "$ONESHOT" = true ]; then
    break
  fi
done

# Handle final cleanup and exit
handle_exit
